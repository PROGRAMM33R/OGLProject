================ Shadery ================ 
• počítačový program určený pro řízení konkrétní
části vykreslovacího řetězce (GPU).
• Pro tvorbu shaderů slouží specializované
programovací jazyky tzv. shader jazyky
– GLSL pro OpenGL
– HLSL pro API DirectX
• Základní typy shaderů:
– Vertex shader
– Fragment shader
– Geometry shader
– Tesellation shader

• (Ne)unifikované shadery – část čipu vyhrazena pouze
pro konkrétní shader (Pevně daný počet vertex a
fragment shaderů)
(GeForce 7800 GTX: 8 vertex a 24 fragment jednotek)
• Unifikované shadery – možnost měnit dynamicky typ
shaderu. (lze počítat jak libovolné shader úlohy (vertex,
fragment, geometrický, teselační).
• podle aktuální potřeby lze využívat všechny shadery
• Unifikované shadery však nemohou být tak efektivní jako
shadery určeny pouze pro konkrétní typ úloh

• Vertex shader (vrcholový procesor)- transformace
vrcholů, normál, texturovací souřadnice, transformace
světla atd.
• Mění polohu vrcholu ale nemůže ani přidávat ani rušit
vrcholy
• Nemá informaci o tělese (nezná sousedy)
• Vypočtené hodnoty se z VS interpolují do fragmentů
• Fragment shader (fragmentový procesor) výpočet barvy
pro jednotlivé fragmenty, čtení z texturovací jednotky
• Výpočet osvětlení, mlhy atd.
• Nemůže změnit souřadnice (x,y)

• Geometry shader – umožňuje měnit geometrii v
reálném čase (vstupem výstup z Vertex Shaderu)

• Teselace – zjemňování trojúhelníkové sítě 

== Vykreslovací řetězec ==
-->> Vertex shader -->> Teselation Controll Shader -->> Teselation Fixed -->> Teselation Evaluation Shader -->>
-->> Geometry Shader -->> Fragment Shader -->> Framebuffer 

Fragment je objekt vzniklý po rasterizaci a může
obsahovat různé hodnoty (barvu, normálu …)
• může přispět k barvě pixelu
• ale taky může být zahozen (např. depth-test)
Pixel se může skládat z více fragmentů
• anti-aliasing

================ Vertex Buffer Object (VBO) ================ 
• Rozšiřuje možnosti Vertex Array
• Data uložena přímo v paměti grafické karty (snížení času
potřebného pro rendering).
• Data obvykle obsahují jednotlivé vrcholy, normály,
texturovací souřadnice apod.
• Existuje i tzv. index buffer s indexy určujícími jednotlivé
plochy (trojúhelníky). Vhodné při opakování vrcholů. 

================ Transformace v OpenGL ================ 
• Model – upravují vlastnosti jednotlivých těles
• View – nastavuje pozici kamery
• Projection – nastavuje vlastnosti promítání (ortogonální,
perspektivní)

================ Nastavení kamery ================ 
glm::mat4 camera=glm::lookAt(Eye, Center, UP);
• Eye – definuje bod ve kterém bude kamera umístěna.
• Center – definuje bod, kterým se kamera dívá (střed scény).
• Up – definuje kterým směrem bude natočen 3D svět v kameře.

================ Stínování (shading) ================ 
• vykreslování barevných objektů různými odstíny barev.
• lze odlišit křivosti ploch a tím docílit lepšího prostorového vjemu.
• neplést s výpočtem vrženého stínu.
Základní typy stínování
• Konstantní stínování
• Gouraudovo stínování (Interpolace barvou)
• Phongovo stínování (Interpolace normálových vektorů)

== Konstantní stínování
• Nejjednodušší a zároveň velmi rychlá metoda vystínování prostorového
objektu.
• Samotný algoritmus počítá s tím, že každá plocha má pouze jednu normálu.
• Podle normály je vypočítána barva, která je následně přiřazena všem pixelům
dané plochy.
Nevýhody
• celá plocha má naprosto stejnou barvu
• do světelného modelu není zahrnuto zrcadlové osvětlení
(odlesky na zobrazovaném objektu mohou mít i jinou barvu než jakou má objekt).

== Gouraudovo stínování (Interpolace barvou)
Normálový vektor nr vypočteme jako
aritmetický průměr vektorů okolních plošek: nr = (n1+n 2+n 3+n 4+ n 5) / 5
Pozor! Není možno vždy použít.

== Výpočet jasu
pro každý pixel se provede, jako lineární interpolaci v dané plošce.
Ať jde o trojúhelník nebo n-úhelník.

== Phongovo stínování
... interpolaci normálových vektorů plošky.
Interpolaci provádíme po řádcích.
U Guraudova stínování jsme interpolovali intenzitu.

================ Lokální vs. globální zobrazovací metody ================ 
Lokální zobrazovací metody
• Pouze přímé osvětlení.
• Objekty se navzájem neovlivňují z hlediska osvětlení (vidíme jen to,
co je osvětlené).
• Počítáme pouze s jedním odrazem paprsku od povrchu objektu. Každý
objekt ve scéně má individuálně (lokálně) vyhodnocen osvětlovací
model nezávisle na ostatních objektech.
• Jediný případ, kdy se pozice objektů bere v potaz, je při vypočtu
viditelnosti (Z-buffer).
Globální
• světelnými zdroji mohou být objekty samy sobě. Metody pracují
s vícenásobnými odrazy světla. 

================ Algoritmy viditelnosti ================ 
Podle výsledných dat
• Vektorové algoritmy - geometrické prvky vrcholy, hrany a
stěny. Výstupem vektorové řešení.
• Rastrové algoritmy - výsledkem je rastrový obraz (jednotlivé
pixely obsahující barvu), většina současných metod.
Podle místa řešení
• Řešení v prostoru objektů - porovnávání vzájemné polohy
těles O(n2
).
• Řešení v prostoru obrazu - pracujeme s promítnutými a
rasterizovanými objekty. Pro pixely hledáme nejbližší objekty

================ Back (front) - face culling ================ 
Přední (normála) a zadní strana plochy
U některých objektů je zbytečné vykreslovat obě plochy
Zapnutí odstraňování
glEnable(GL_CULL_FACE);
Nastavení funkce
glCullFace(GL_FRONT); // přední strany
glCullFace(GL_BACK); // zadní strany
glCullFace(GL_FRONT_AND_BACK); // obě strany 

================ Rastrové algoritmy ================ 
Malířův algoritmus (Painter’s algorithm)
Dělení obrazovky (Warnosk subdivision)
Plovoucí horizont (Floating Horizon Algorithm)
Paměť hloubky (Z-buffer, depth-buffer)

== Malířův algoritmus (postupné nanášení barev)
Algoritmus je možno rozdělit do bodů:
1. Porovnej jednotlivé plochy z hlediska jejich z-tových souřadnic.
Plocha s menší z-tovou souřadnici bude kreslena první.
2. Jestliže se plochy nepřekrývají, potom na pořadí kresby nezáleží.
3. Pokud se protínají -rozdělit na nepřekrývající plochy
Třídící algoritmy !!!

== Warnockův algoritmus – Dělení obrazovky (J Warnock, 1969)
1. Všechny plošky leží mimo zónu - zůstane barva pozadí. (a)
2. Oblast obsahuje právě jeden celý n-úhelník.
Daná oblast se vyplní barvou a zbytek -pozadím. (b)
3. Oblast protíná právě jeden n-úhelník.
Daná část se vyplní barvou, zbytek pozadí. (c)
4. Pokud zobrazovaná část je celá uvnitř jednoho n-úhelníka, potom se celá oblast
zobrazí barvou nejbližšího n-úhelníka, který oblast obklopuje. (d)
5. Pokud nenastane jeden z vyjmenovaných případů - oblast se rozdělí.

== Plovoucí horizont 
vhodné pro zobrazení funkci dvou proměnných (vyjádřenou v explicitním tvaru)
Postup:
1. Inicializujeme masku horizontu
- nastavení Dolní hranice masky .....dolní okraj kreslící plochy;
- nastavení Horní hranice masky .....horní okraj kreslící plochy.
2. Kresba mimo hranice nastavené masky. (Bresenhamův algoritmus.)
3. Přestavení horizontů.
4. Zpět k bodu 2. až do vyčerpání intervalu <yc, yd >.

== Z-buffer - paměť hloubky
1) Nejznámější a nejefektivnější
2) Každá plocha se zpracovává pouze jednou
3) Doba zpracování roste s počtem ploch lineárně (záleží i na velikosti ploch)
4) Není potřeba žádné třídění nebo pomocné datové struktury
5) Možnost paralelních procesů
Zapnutí, vypnutí z-bufferu
glEnable(GL_DEPTH_TEST);
glDisable(GL_DEPTH_TEST);
Vyčistění z-bufferu
glClear(GL_DEPTH_BUFFER_BIT);
Obvykle
glClear(GL_COLOR_BUFFER_BIT |
GL_DEPTH_BUFFER_BIT);
Zapnutí a vypnutí zapisování do z-bufferu
glDepthMask(bool write); //GL_FALSE, GL_TRUE

================ Globální zobrazovací metody ================ 
Sledování paprsku (ray tracing)
• Ray casting (sledování paprsku prvního řádu) paprsek, nejbližší těleso,
výpočet barvy
• Vyššího řádu
• Primární paprsek (primary ray) - z místa pozorovatele do scény
• Sekundární paprsek (secondary ray) - odražené nebo paprsky
procházející průhlednými tělesy
• Stínový paprsek (shadow ray) - hledám, zda je nějaký objekt stínící
aktuální pozici (stačí jeden, nehledám nejbližší)
Radiozitní metoda (Radiosity )

== Ray tracing
• Ray tracing (sledování paprsku) - globální vykreslovací
metoda (sledování fotonů)
• Dělení - ze světelného zdroje nebo od pozorovatele
Phongův osvětlovací model I=Is+Id+Ia+Ir+It
(odražený a lomený paprsek)

-- Nevýhody zpětného sledování paprsku
• Zobrazování ostrých stínů.
• Lesklé plochy (zrcadla) sice odrážejí své okolí, ale neodráží
světlo do okolí (sekundární zdroj světla).
• Při změně scény (místo pozorovatele, nové světlo, nový
objekt, …) se musí vyhodnotit znovu.
• Klasická metoda pouze bodové světla

== Radiosity
Renderovací metoda představena 1984 výzkumníky na Cornell University
Polygony rozděleny na malé plošky, výpočet konfiguračního faktoru (vliv
každé plošky na každou jinou plošku ve scéně).
• Časově náročné.
• Vychází ze zákona zachování energie
(vyžaduje energeticky uzavřenou scénu).
• Nedokáže pracovat s průhlednými objekty, zrcadly.
Výpočet probíhá:
• iteračně (progresivně),
• řešením soustavy rovnic (maticové řešení). 

================ Frame buffer ================ 
Frame buffer slouží pro ukládání výsledku zobrazovacího řetězce
Obvykle lze použít tyto buffery:
• Color buffer - barvový buffer
• Depth buffer - paměť hloubky (z-buffer)
• Stencil buffer - paměť šablony
• Accumulation buffer - akumulační buffer

================ Stencil Buffer ================ 
Stencil buffer je volitelné rozšíření depth bufferu
glEnable(GL_STENCIL_TEST); 